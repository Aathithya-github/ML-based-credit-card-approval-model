# -*- coding: utf-8 -*-
"""credit card_CA1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BY2zwyOHPaa9zYi7TnSfhC_gHXo35Z-i
"""

# Commented out IPython magic to ensure Python compatibility.
#authors: Adarsh, Arun, Aathithya
#objective: To find optimal k value
#input: Dataset
#output: Accuracy
import pandas as pd #data analysis toolkit
import matplotlib.pyplot as plt # for plotting graphs
import numpy as np # for high level computations
# %matplotlib inline

from sklearn.preprocessing import StandardScaler # standardization of values

from sklearn.preprocessing import MinMaxScaler # Normalization of values
from sklearn.model_selection import train_test_split # to split data

from sklearn.neighbors import KNeighborsClassifier #KNN classifier
from sklearn.model_selection import StratifiedKFold

from sklearn.metrics import confusion_matrix, accuracy_score # to get confusion matrix and accuracy
from sklearn.model_selection import cross_val_score # to perform evaluation and cross-validation

data_set = pd.read_csv("/content/clean_dataset (1).csv") # dataset_input

data_set=data_set.drop(['Industry'], axis= 1) # dropping of columns as mentioned
data_set=data_set.fillna (data_set.mean()) # mean for missing data

data_set = np.round(data_set, decimals=2) # rouding all values in dataset to 2 decimal places
data_set.head() # first 5 values in datase

dset_modified = data_set.drop('Approved', axis=1) # dataset without class feature
data_set_feat = pd.DataFrame(dset_modified, columns=data_set.columns[:-1]) #dataset without class feature
data_set_feat = np.round(data_set_feat, decimals=2) # rouding all values to 2 decimal places

#test_train split with test size 30% and train size -70%
one_train, one_test, two_train, two_test = train_test_split(data_set_feat, data_set['Approved'],test_size=0.30)

#Computation of accuracy rates for various neighbour values
Accurate_rates = []
for i in range(1,40):

  k_nearest_neighbour = KNeighborsClassifier(n_neighbors=i)
  final_score = cross_val_score(k_nearest_neighbour, data_set_feat, data_set['Approved'], cv=5)
  Accurate_rates.append(final_score.mean())

plt.figure(figsize=(10,6))
plt.plot(range(1,40), Accurate_rates, color='blue', linestyle='dashed', marker='o', markerfacecolor='red', markersize=10)
plt.title('Accuracy Rate vs. K Value')
plt.xlabel('K')
plt.ylabel('Accuracy Rate')

max_index  = Accurate_rates.index(max(Accurate_rates))

k_nearest_neighbour = KNeighborsClassifier(n_neighbors = max_index)
k_nearest_neighbour.fit(one_train,two_train)
prediction = k_nearest_neighbour.predict(one_test)

print('For K=',max_index)
print('Confusion matrix: ')
print('\n')
print(confusion_matrix(two_test,prediction))
print('\n')
print('Accuracy rate: ',round(accuracy_score(two_test,prediction),2)*100,'%')

a=20

k_nearest_neighbour = KNeighborsClassifier(n_neighbors = a)
k_nearest_neighbour.fit(one_train,two_train)
prediction = k_nearest_neighbour.predict(one_test)

print('For K=',a)
print('Confusion matrix: ')
print('\n')
print(confusion_matrix(two_test,prediction))
print('\n')
print('Accuracy rate: ',round(accuracy_score(two_test,prediction),2)*100,'%')

scaled = MinMaxScaler() #function MinMax scaler for normalising values

scaled.fit(data_set.drop('Approved',axis=1)) # dropping class-feature

MinMaxScaler()

dset_modified = scaled.transform(data_set.drop('Approved',axis=1)) #dropping class-feature

data_set_feat = pd.DataFrame(dset_modified, columns=data_set.columns[:-1]) #dropping class-feature

data_set_feat= np.round(data_set_feat, decimals=2) #rounding all values to 2 decimals

data_set_feat.head() #dataset_after_normalization

#test_train split with test size 30% and train size -70%
one_train, one_test, two_train, two_test = train_test_split(data_set_feat, data_set['Approved'],test_size=0.30)

#Computation of accuracy rates for various neighbour values
Accurate_rates = []

for i in range(1,40):

  k_nearest_neighbour = KNeighborsClassifier(n_neighbors=i)
  final_score = cross_val_score(k_nearest_neighbour, data_set_feat, data_set['Approved'], cv=5)
  Accurate_rates.append(final_score.mean())


plt.figure(figsize=(10,6))

plt.plot(range(1,40), Accurate_rates, color='blue', linestyle='dashed', marker='o', markerfacecolor='red', markersize=10)

plt.title('Accuracy Rate vs. K Value')
plt.xlabel('K')
plt.ylabel('Accuracy Rate')